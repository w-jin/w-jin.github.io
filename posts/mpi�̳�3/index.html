<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.74.3" /><meta name="theme-color" content="#fff" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>MPI教程3 | wjin</title>

    <link rel="stylesheet" href="/css/meme.min.0d8ee052f6b06e8c0ef97f7dbabc6037a8df64f263f450df7a1476c159abecef.css" integrity="sha256-DY7gUvawbowO&#43;X99urxgN6jfZPJj9FDfehR2wVmr7O8=" />

    
    
        <script src="/js/meme.min.a7fc64afcf2ed740fea88806e4d00d22b9a1b9b4bb9a4556d6bb5325b5d61f96.js" integrity="sha256-p/xkr88u10D&#43;qIgG5NANIrmhubS7mkVW1rtTJbXWH5Y="></script>

    

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;display=swap" media="print" onload="this.media='all'" />
        <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;display=swap" /></noscript>

    <meta name="author" content="wjin" /><meta name="description" content="聚合通信 点对点通信是两个进程参与的通信，其中一个进程发送消息，另一个进程接收消息，而……" />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2a6df4" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="wjin" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="wjin" />
    <meta name="msapplication-starturl" content="../../" />
    <meta name="msapplication-TileColor" content="#fff" />
    <meta name="msapplication-TileImage" content="../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="https://w-jin.gitee.com/posts/mpi%E6%95%99%E7%A8%8B3/" />
    

<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "datePublished": "2020-08-06T08:46:58+08:00",
        "dateModified": "2020-08-15T22:24:35+08:00",
        "url": "https://w-jin.gitee.com/posts/mpi%E6%95%99%E7%A8%8B3/",
        "headline": "MPI教程3",
        "description": "聚合通信 点对点通信是两个进程参与的通信，其中一个进程发送消息，另一个进程接收消息，而……",
        "inLanguage" : "zh-CN",
        "articleSection": "posts",
        "wordCount":  10477 ,
        "image": ["https://w-jin.gitee.com/assets/gather.png","https://w-jin.gitee.com/assets/scatter.png","https://w-jin.gitee.com/assets/alltoall.png","https://w-jin.gitee.com/assets/reduce.png","https://w-jin.gitee.com/assets/allreduce.png","https://w-jin.gitee.com/assets/reduce_scatter.png","https://w-jin.gitee.com/assets/scan.png"],
        "author": {
            "@type": "Person",
            "description": "我空空如也",
            "email": "wjiner@outlook.com",
            "image": "https://w-jin.gitee.com/icons/avatar.png",
            "url": "https://w-jin.gitee.com/",
            "name": "wjin"
        },
        "license": "[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)",
        "publisher": {
            "@type": "Organization",
            "name": "wjin",
            "logo": {
                "@type": "ImageObject",
                "url": "https://w-jin.gitee.com/icons/logo.png"
            },
            "url": "https://w-jin.gitee.com/"
        },
        "mainEntityOfPage": {
            "@type": "WebSite",
            "@id": "https://w-jin.gitee.com/"
        }
    }
</script>

    

<meta name="twitter:card" content="summary_large_image" />



    



<meta property="og:title" content="MPI教程3" />
<meta property="og:description" content="聚合通信 点对点通信是两个进程参与的通信，其中一个进程发送消息，另一个进程接收消息，而……" />
<meta property="og:url" content="https://w-jin.gitee.com/posts/mpi%E6%95%99%E7%A8%8B3/" />
<meta property="og:site_name" content="wjin" />
<meta property="og:locale" content="zh" /><meta property="og:image" content="https://w-jin.gitee.com/assets/gather.png" />
<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2020-08-06T08:46:58&#43;08:00" />
    <meta property="article:modified_time" content="2020-08-15T22:24:35&#43;08:00" />
    
    <meta property="article:section" content="posts" />



    
</head>

    <body>
        <div class="container">
            
    <header class="header">
        
            <div class="header-wrapper">
                <div class="header-inner single">
                    
    <div class="site-brand">
        
            <a href="/" class="brand">wjin</a>
        
    </div>

                    <nav class="nav">
    <ul class="menu" id="menu">
        
            
        
        
        
        
            
                <li class="menu-item"><a href="/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="icon home"><path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"/></svg><span class="menu-item-name">首页</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/posts/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon archive"><path d="M32 448c0 17.7 14.3 32 32 32h384c17.7 0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6 0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3 0 64v48c0 8.8 7.2 16 16 16h480c8.8 0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"/></svg><span class="menu-item-name">文章</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/categories/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon th"><path d="M149.333 56v80c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V56c0-13.255 10.745-24 24-24h101.333c13.255 0 24 10.745 24 24zm181.334 240v-80c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256 0 24.001-10.745 24.001-24zm32-240v80c0 13.255 10.745 24 24 24H488c13.255 0 24-10.745 24-24V56c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24zm-32 80V56c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256 0 24.001-10.745 24.001-24zm-205.334 56H24c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24zM0 376v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H24c-13.255 0-24 10.745-24 24zm386.667-56H488c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zm0 160H488c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zM181.333 376v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24z"/></svg><span class="menu-item-name">分类</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/tags/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" class="icon tags"><path d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"/></svg><span class="menu-item-name">标签</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/about/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon user-circle"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6 0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7 0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4 0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9 14.3 0 28-2.7 40.9-6.9 2.3-.7 4.7-1.1 7.1-1.1 42.9 0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"/></svg><span class="menu-item-name">关于</span></a>
                </li>
            
        
            
                
                    
                    
                        <li class="menu-item">
                            <a id="theme-switcher" href="#"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-light"><path d="M193.2 104.5l48.8-97.5a18 18 0 0128 0l48.8 97.5 103.4 -34.5a18 18 0 0119.8 19.8l-34.5 103.4l97.5 48.8a18 18 0 010 28l-97.5 48.8 34.5 103.4a18 18 0 01-19.8 19.8l-103.4-34.5-48.8 97.5a18 18 0 01-28 0l-48.8-97.5l-103.4 34.5a18 18 0 01-19.8-19.8l34.5-103.4-97.5-48.8a18 18 0 010-28l97.5-48.8-34.5-103.4a18 18 0 0119.8-19.8zM256 128a128 128 0 10.01 0M256 160a96 96 0 10.01 0"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-dark"><path d="M27 412a256 256 0 10154-407a11.5 11.5 0 00-5 20a201.5 201.5 0 01-134 374a11.5 11.5 0 00-15 13"/></svg></a>
                        </li>
                    
                
            
        
            
                
            
        
    </ul>
</nav>

                    
                </div>
            </div>
            
    <input type="checkbox" id="nav-toggle" aria-hidden="true" />
    <label for="nav-toggle" class="nav-toggle"></label>
    <label for="nav-toggle" class="nav-curtain"></label>


        
    </header>




            
            
    <main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post" data-align="justify" data-type="posts" data-toc-num="true">

            <h1 class="post-title">MPI教程3</h1>

            

            
                
            

            
                

<div class="post-meta">
    
        
        <time datetime="2020-08-06T08:46:58&#43;08:00" class="post-meta-item published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"/></svg>&nbsp;2020.8.6</time>
    
    
        
        <time datetime="2020-08-15T22:24:35&#43;08:00" class="post-meta-item modified"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M400 64h-48V12c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v52H160V12c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v52H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 400H54a6 6 0 0 1-6-6V160h352v298a6 6 0 0 1-6 6zm-52.849-200.65L198.842 404.519c-4.705 4.667-12.303 4.637-16.971-.068l-75.091-75.699c-4.667-4.705-4.637-12.303.068-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l44.104 44.461 111.072-110.181c4.705-4.667 12.303-4.637 16.971.068l22.536 22.718c4.667 4.705 4.636 12.303-.069 16.97z"/></svg>&nbsp;2020.8.15</time>
    
    
    
        
        
        
            
        
    
    
        
        <span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;10477</span>
    
    
        
        <span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;21&nbsp;分钟</span>
    
    
    
</div>

            

            <nav class="contents">
  <h2 id="contents" class="contents-title">目录</h2><ol class="toc">
    <li><a id="contents:聚合通信" href="#聚合通信">聚合通信</a>
      <ol>
        <li><a id="contents:通信" href="#通信">通信</a>
          <ol>
            <li><a id="contents:广播" href="#广播">广播</a></li>
            <li><a id="contents:收集" href="#收集">收集</a></li>
            <li><a id="contents:散发" href="#散发">散发</a></li>
            <li><a id="contents:全互换" href="#全互换">全互换</a></li>
            <li><a id="contents:例3行主序下矩阵与向量乘法" href="#例3行主序下矩阵与向量乘法">例3：行主序下矩阵与向量乘法</a></li>
            <li><a id="contents:例4使用聚合通信计算定积分" href="#例4使用聚合通信计算定积分">例4：使用聚合通信计算定积分</a></li>
          </ol>
        </li>
        <li><a id="contents:进程同步" href="#进程同步">进程同步</a></li>
        <li><a id="contents:计算" href="#计算">计算</a>
          <ol>
            <li><a id="contents:mpi_reduce" href="#mpi_reduce">MPI_Reduce</a></li>
            <li><a id="contents:mpi_allreduce" href="#mpi_allreduce">MPI_Allreduce</a></li>
            <li><a id="contents:mpi_reduce_scatter" href="#mpi_reduce_scatter">MPI_Reduce_scatter</a></li>
            <li><a id="contents:mpi_scan" href="#mpi_scan">MPI_Scan</a></li>
            <li><a id="contents:二元运算" href="#二元运算">二元运算</a></li>
            <li><a id="contents:例5列主序下矩阵与向量乘法" href="#例5列主序下矩阵与向量乘法">例5：列主序下矩阵与向量乘法</a></li>
          </ol>
        </li>
        <li><a id="contents:文档" href="#文档">文档</a></li>
      </ol>
    </li>
  </ol>
</nav><div class="post-body">
              <h2 id="聚合通信"><a href="#聚合通信" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:聚合通信" class="headings">聚合通信</a></h2>
<p>点对点通信是两个进程参与的通信，其中一个进程发送消息，另一个进程接收消息，而聚合通信是在一个进程组内发生的通信，进程组内所有进程都要参与。调用一个聚合通信函数时，通信器中的所有进程必须同时调用同一函数，共同参与操作。通信函数在各个进程中的调用方式完全相同，而不是像点对点通信那样分为发送函数和接收函数。</p>
<p>聚合通信函数主要为分为三个功能：</p>
<ul>
<li>通信：完成组内进程间的数据传输。这部分的功能使用点对点通信也能完成，但聚合通信性能更好，表达更简洁。</li>
<li>同步：实现组内所有进程在特定点的执行速度保持一致</li>
<li>计算：对给定的数据在进程间完成一定的操作</li>
</ul>
<h3 id="通信"><a href="#通信" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:通信" class="headings">通信</a></h3>
<h4 id="广播"><a href="#广播" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:广播" class="headings">广播</a></h4>
<p>广播指一个进程(称为根进程)同时发送同样的消息给通信器中的所有其它进程，MPI中的广播函数是MPI_Bcast。MPI_Bcast的函数原型为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Bcast</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>           <span class="c1">// 通信消息缓冲区的起始位置
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>              <span class="c1">// 广播 / 接收数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">datatype</span><span class="p">,</span>  <span class="c1">// 广播 / 接收数据的数据类型
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">root</span><span class="p">,</span>               <span class="c1">// 广播数据的根进程号
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>其效果是将根进程中buffer数组中的数据拷贝到其它进程的buffer中去。对于广播调用，不论是发送消息的根进程，还是接收消息的其它进程，在调用形式上完全一致。</p>
<p>MPI_Bcast一般用于将某个进程的计算结果告知其它所有进程，然后其它进程利用结果进行后续计算。例如：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>
    
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 打开一个数据文件，从里面读出矩阵的数据
</span><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">file</span><span class="p">{</span><span class="s">&#34;mat.txt&#34;</span><span class="p">};</span>
        
        <span class="c1">// 行数和列数
</span><span class="c1"></span>        <span class="n">file</span> <span class="o">&gt;&gt;</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        
        <span class="c1">// 其它数据...
</span><span class="c1"></span>    <span class="p">}</span>
    
    <span class="n">MPI_Bcast</span><span class="p">(</span><span class="n">dim</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
        
    <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>其中mat.txt的内容大致为：</p>
<pre><code>10 10
1 2 3 4 5 6 7 8 9 10
...
</code></pre><p>广播后每个进程中M和N的值都是10。</p>
<p>注意：mat.txt使用的编码不要带有头部信息，如UTF-8 with BOM、UTF-16、UTF-32，否则可能出错。</p>
<p>聚合通信函数一般可以由点对点通信函数实现，MPI_Bcast可以这样实现：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">bcast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">MPI_Datatype</span> <span class="n">datatype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="p">,</span> <span class="n">MPI_Comm</span> <span class="n">comm</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// root进程向i号进程发送数据
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span>
                <span class="n">MPI_Send</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 其它进程接收root进程发送过来的数据
</span><span class="c1"></span>        <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">MPI_STATUS_IGNORE</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>这个实现中没有实现返回错误码，性能也不如MPI_Bcast，因为无法根据网络拓扑进行优化。</p>
<h4 id="收集"><a href="#收集" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:收集" class="headings">收集</a></h4>
<p>数据收集指一个进程(根进程)，从指定通信器中的所有进程(包括根进程)，收集数据。收集到的数据将按照进程的id顺序放入指定的接收缓冲区内。MPI的数据收集函数有：MPI_Gather, MPI_Gatherv, MPI_Allgather, 和MPI_Allgatherv。它们分别用于等长的数据块收集，不等长的数据块收集，等长的数据块收集加广播，和不等长的数据块收集加广播。下面是Gather的示意图。</p>
<p><img src="assets/gather.png" alt="gather"></p>
<p>MPI_Gather的函数声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Gather</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sendcount</span><span class="p">,</span>          <span class="c1">// 发送数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">sendtype</span><span class="p">,</span>  <span class="c1">// 发送数据类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">recvcount</span><span class="p">,</span>          <span class="c1">// 接收数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">recvtype</span><span class="p">,</span>  <span class="c1">// 接收数据的类型
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">root</span><span class="p">,</span>               <span class="c1">// 根进程的编号
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>调用MPI_Gather，根进程将从通信器comm内的每个进程收集sendcount个类型为sendtype的数据，将其转换成recvcount个类型为recvtype的数据，按照进程编号顺序放入recvbuf中。参数recvbuf, recvcount, 和recvtype仅对root进程有意义。</p>
<p>需要注意的是，recvcount指的是从每个进程中接收的数据个数，而不是从所有进程接收的数据长度之和。当sendtype和recvtype相同的时候，sendcount和recvcount应当相等。</p>
<p>例1：各进程生成n个数，然后收集到0号进程上来。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">send_array</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// 发送缓冲区
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">recv_array</span><span class="p">;</span>     <span class="c1">// 接收缓冲区，只有根进程用得上
</span><span class="c1"></span>
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>

    <span class="c1">// 0号进程生成0,1,2,...,n-1，1号进程生成n,n+1,...
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">send_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">recv_array</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="p">);</span>

    <span class="n">MPI_Gather</span><span class="p">(</span>
        <span class="n">send_array</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>  <span class="c1">// 发送缓冲区
</span><span class="c1"></span>        <span class="n">n</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span>         <span class="c1">// 每个进程发送n个int
</span><span class="c1"></span>        <span class="n">recv_array</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>  <span class="c1">// 接收缓冲区
</span><span class="c1"></span>        <span class="n">n</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span>         <span class="c1">// 根进程从每个进程接收n个int
</span><span class="c1"></span>        <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span>   <span class="c1">// 0号进程为根进程
</span><span class="c1"></span>    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">recv_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">MPI_Finalize</span><span class="p">();</span>
   
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>4个进程的执行结果：</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
</code></pre><p>MPI_Gather函数的最大限制在于从每个进程上收集的数据个数必须相同，而划分任务时，任务的规模不总是进程数量的倍数，此时应当使用MPI_Gatherv函数。MPI_Gatherv的声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Gatherv</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sendcount</span><span class="p">,</span>          <span class="c1">// 发送数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">sendtype</span><span class="p">,</span>  <span class="c1">// 发送数据类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">recvcounts</span><span class="p">,</span>        <span class="c1">// 从每个进程接收的数据个数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">displs</span><span class="p">,</span>            <span class="c1">// 接收数据在消息缓冲区中的索引
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">recvtype</span><span class="p">,</span>  <span class="c1">// 接收数据的类型
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">root</span><span class="p">,</span>               <span class="c1">// 根进程的编号
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>MPI_Gatherv允许每个进程发送数量不同的数据，并且根进程可以通过displs数组来安排接收到的数据安放于何处。各个进程发送多少个数据通过参数sendcount指定，这个值在不同进程中可以不同。recvbuf, recvcounts, displs, recvtype仅对根进程有意义。数组recvcounts和displs的元素个数等于进程数，用于指定从每个进程接收的数据个数和它们在recvbuf中的起始位移，如recvcounts[i]表示从i号进程收集的数据个数。数组元素类型必须统一，因此recvtype是标量类型。</p>
<p>例2：生成n个随机数。</p>
<p>每个进程应当生成多少个呢？如果直接用n除以np向上取整，则可能造成负载不均衡，如4个进程生成17个随机数，每个进程分别生成5、5、5、2个。负载均衡的做法应当为5、4、4、4个，即使用n除以np向下取整，设余数为r，则前r个进程每个进程多算一个。生成一个随机数的代价不是很高，前一种做法最后一个进程最多比其它进程少算np-1个，实际差距比起数据规模来讲也许并不大，具体问题具体分析即可。这里采用后一种做法。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>

    <span class="c1">// 本进程需要生成多少个数据
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">send_array</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>  <span class="c1">// 发送缓冲区
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">recv_array</span><span class="p">;</span>         <span class="c1">// 接收缓冲区，只有根进程用得上
</span><span class="c1"></span>
    <span class="c1">// 生成随机数
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">re</span><span class="p">{</span><span class="n">rd</span><span class="p">()};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">send_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">re</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">recv_array</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>

    <span class="c1">// 将随机数收集到0号进程上来。以4个进程17个数为例，从各进程接收的数据量为：
</span><span class="c1"></span>    <span class="c1">// 5 4 4 4，位移量为：0 5 9 13
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">recvcounts</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">displs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">recvcounts</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
        <span class="n">displs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
        <span class="n">recvcounts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">displs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">recvcounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">displs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">recvcounts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">MPI_Gatherv</span><span class="p">(</span>
        <span class="n">send_array</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>  <span class="c1">// 发送缓冲区
</span><span class="c1"></span>        <span class="n">count</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span>     <span class="c1">// 每个进程发送count个int
</span><span class="c1"></span>        <span class="n">recv_array</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>  <span class="c1">// 接收缓冲区
</span><span class="c1"></span>        <span class="n">recvcounts</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>  <span class="c1">// 根进程从每个进程接收多少个数据
</span><span class="c1"></span>        <span class="n">displs</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>      <span class="c1">// 从每个进程接收的数据放于recv_array中的起始位置
</span><span class="c1"></span>        <span class="n">MPI_INT</span><span class="p">,</span>            <span class="c1">// 根进程从每个进程接收N个int
</span><span class="c1"></span>        <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span>   <span class="c1">// 0号进程为根进程
</span><span class="c1"></span>    <span class="p">);</span>

    <span class="c1">// 0号进程打印
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">recv_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">MPI_Finalize</span><span class="p">();</span>
   
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>从每个进程接收的数据个数也可以直接收集到0号进程上来：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">MPI_Gather</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="n">recvcounts</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>除了MPI_Gather和MPI_Gatherv以外，MPI还提供两个收集函数MPI_Allgather和MPI_Allgatherv，它们在MPI_Gather和MPI_Gatherv的基础上，不仅会收集数据，还会将数据广播到所有进程，。MPI_Allgather的声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Allgather</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sendcount</span><span class="p">,</span>          <span class="c1">// 向每个进程发送的数据个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">sendtype</span><span class="p">,</span>  <span class="c1">// 发送数据类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">recvcount</span><span class="p">,</span>          <span class="c1">// 接收数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">recvtype</span><span class="p">,</span>  <span class="c1">// 接收数据的类型
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>MPI_Allgather和MPI_Gather比起来只少了一个root参数，其它参数含义与MPI_Gather相同。MPI_Allgather相当于以任意一个进程为根进程调用一次MPI_Gather，然后再广播：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 以0号进程为根进程
</span><span class="c1"></span><span class="n">MPI_Gather</span><span class="p">(</span><span class="n">sendbuf</span><span class="p">,</span> <span class="n">sendcount</span><span class="p">,</span> <span class="n">sendtype</span><span class="p">,</span> <span class="n">recvbuf</span><span class="p">,</span> <span class="n">recvcount</span><span class="p">,</span> <span class="n">recvtype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="p">);</span>
<span class="n">MPI_Bcast</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">,</span> <span class="n">np</span> <span class="o">*</span> <span class="n">recvcount</span><span class="p">,</span> <span class="n">recvtype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>或者以任意进程为根进程各调用一次MPI_Gather：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">root</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">root</span><span class="p">)</span>
    <span class="n">MPI_Gather</span><span class="p">(</span><span class="n">sendbuf</span><span class="p">,</span> <span class="n">sendcount</span><span class="p">,</span> <span class="n">sendtype</span><span class="p">,</span> <span class="n">recvbuf</span><span class="p">,</span> <span class="n">recvcount</span><span class="p">,</span> <span class="n">recvtype</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">comm</span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>与MPI_Allgather类似，MPI_Allgatherv用于收集不同长度的数据块并广播，其声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Allgatherv</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sendcount</span><span class="p">,</span>          <span class="c1">// 发送数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">sendtype</span><span class="p">,</span>  <span class="c1">// 发送数据类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">recvcounts</span><span class="p">,</span>        <span class="c1">// 从每个进程接收的数据个数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">displs</span><span class="p">,</span>            <span class="c1">// 接收数据在消息缓冲区中的索引
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">recvtype</span><span class="p">,</span>  <span class="c1">// 接收数据的类型
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>需要注意MPI_Allgather和MPI_Allgatherv中的recvbuf、recvcounts、displs和recvtype需要在每个进程中都有正确的定义。</p>
<h4 id="散发"><a href="#散发" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:散发" class="headings">散发</a></h4>
<p>散发操作是数据收集操作的逆向操作，它将一个进程中的数据按块散发给通信器中的所有进程。与MPI_Gather和MPI_Gatherv类似，MPI提供两个散发函数MPI_Scatter和MPI_Scatterv，分别用于将数据等长分割和不等长分割。下面是Scatter的示意图。</p>
<p><img src="assets/scatter.png" alt="scatter"></p>
<p>MPI_Scatter的声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_scatter</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sendcount</span><span class="p">,</span>          <span class="c1">// 发送数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">sendtype</span><span class="p">,</span>  <span class="c1">// 发送数据类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">recvcount</span><span class="p">,</span>          <span class="c1">// 接收数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">recvtype</span><span class="p">,</span>  <span class="c1">// 接收数据的类型
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">root</span><span class="p">,</span>               <span class="c1">// 根进程的编号
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>MPI_Scatter用于散发相同长度数据块。根进程将自己的sendbuf中的np个连续存放的数据块按进程号的顺序依次分发到comm的各个进程 (包括根进程自己) 的recvbuf中，这里np代表comm中的进程数。sendcnt和sendtype给出sendbuf中每个数据块的大小和类型，recvcnt和recvtype给出recvbuf的大小和类型，其中参数sendbuf、sendcnt和sendtype仅对根进程有意义。</p>
<p>需要特别注意的是，在根进程中，参数sendcnt指分别发送给每个进程的数据长度，而不是发送给所有进程的数据长度之和。因此，当recvtype等于sendtype时，recvcnt应该等于sendcnt。</p>
<p>例2中生成n个随机数，其中n是编译时常量，所有进程运行时都知道，如果n在运行时输入，可能只有0号进程知道，如《广播》一节从文件中读取矩阵规模一样，0号进程要么通过广播告知其它进程，然后按例2计算，要么将每个进程需要处理的数据个数计算好，然后把结果告知其它进程：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">recvcounts</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">displs</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">recvcounts</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
    <span class="n">displs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
    <span class="n">recvcounts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">displs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">recvcounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">displs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">recvcounts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 本进程需要生成多少个数据
</span><span class="c1"></span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">MPI_Scatter</span><span class="p">(</span><span class="n">recvcounts</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">send_array</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>  <span class="c1">// 发送缓冲区
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">recv_array</span><span class="p">;</span>         <span class="c1">// 接收缓冲区，只有根进程用得上
</span></code></pre></td></tr></table></div>
</div>
</div><p>相比于一个进程计算好，再发散到其它进程上，一般更倾向于所有进程各算一个，再收集到某个进程上。</p>
<p>和MPI_Gatherv类似，MPI_Scatterv用于散发长度不同的数据块。MPI_Scatterv的声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Scatterv</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>         <span class="c1">// 发送缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">sendcounts</span><span class="p">,</span>        <span class="c1">// 向每个进程发送的数据个数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">displs</span><span class="p">,</span>            <span class="c1">// 发送数据的偏移
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">sendtype</span><span class="p">,</span>  <span class="c1">// 发送数据类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">recvcount</span><span class="p">,</span>          <span class="c1">// 接收数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">recvtype</span><span class="p">,</span>  <span class="c1">// 接收数据的类型
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">root</span><span class="p">,</span>               <span class="c1">// 根进程的编号
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>MPI_Scatterv允许sendbuf中每个数据块的长度不同并且可以按任意顺序存放。sendbuf、sendcounts、displs和sendtype只对根进程有意义。其使用方法和MPI_Gatherv类似，只是功能完全相反，此处不再赘述。</p>
<h4 id="全互换"><a href="#全互换" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:全互换" class="headings">全互换</a></h4>
<p>全互换操作是组内进程完全交换，每个进程都向其它所有进程发送消息，同时每个进程都从其它所有进程接收消息。全互换操作结束后，每个进程得到的结果是不一样的，它相当于将按行存在的数据转换成按列存放的数据。下面是全互换的示意图：</p>
<p><img src="assets/alltoall.png" alt="alltoall"></p>
<p>图中，$A_{ij}$表示第i个进程中发送缓冲区的第j个数据块。</p>
<p>全互换对应的函数为MPI_Alltoall，其声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Alltoall</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sendcount</span><span class="p">,</span>          <span class="c1">// 每个进程发送的数据个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">sendtype</span><span class="p">,</span>  <span class="c1">// 发送数据类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">recvcount</span><span class="p">,</span>          <span class="c1">// 接收数据的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">recvtype</span><span class="p">,</span>  <span class="c1">// 接收数据的类型
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>MPI_Alltoall要求每段数据的长度相同，为sendcount，共np块。第i个进程把sendbuf中的第j块数据发达到第j个进程的recvbuf的第i个位置。需要注意MPI_Alltoall是以数据块为单位进行置换，不能直接用于转置矩阵。</p>
<h4 id="例3行主序下矩阵与向量乘法"><a href="#例3行主序下矩阵与向量乘法" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:例3行主序下矩阵与向量乘法" class="headings">例3：行主序下矩阵与向量乘法</a></h4>
<p>矩阵在存储上分为行主序存储方式和列主序存储方式，即连续存放的数据是属于同一行还是同一列，两种存储方式是转置关系。如果封装mat(i, j)来访问矩阵，它们的操作基本没有区别，在共享存储式并行框架下很容易写出矩阵与向量的并行乘法：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 行主序
</span><span class="c1"></span>    <span class="kt">double</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span> <span class="p">}</span>
    <span class="c1">// 列主序
</span><span class="c1"></span>    <span class="kt">double</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">num_rows</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_rows</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_cols</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Matrix</span> <span class="n">mat</span><span class="p">;</span>                               <span class="c1">// 矩阵
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">mat</span><span class="p">.</span><span class="n">num_cols</span><span class="p">);</span>    <span class="c1">// 向量
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">mat</span><span class="p">.</span><span class="n">num_rows</span><span class="p">);</span> <span class="c1">// mat * vec
</span><span class="c1"></span>
<span class="cp">#pragma omp parallel for
</span><span class="cp"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="p">.</span><span class="n">num_rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="p">.</span><span class="n">num_cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>但是在非共享存储式并行计算中，矩阵分布式地存储于各个进程，行主序和列主序就有了区别。此处演示行主序存储方式下，矩阵与向量并行乘法。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>
    
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 打开一个数据文件，从里面读出矩阵的数据
</span><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">mat_file</span><span class="p">{</span><span class="s">&#34;mat.txt&#34;</span><span class="p">};</span>
        
        <span class="c1">// 行数和列数
</span><span class="c1"></span>        <span class="n">mat_file</span> <span class="o">&gt;&gt;</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="c1">// 矩阵数据
</span><span class="c1"></span>        <span class="n">mat</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">mat_file</span> <span class="o">&gt;&gt;</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="n">MPI_Bcast</span><span class="p">(</span><span class="n">dim</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>   <span class="c1">// 行数
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// 列数
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 本进程多少行
</span><span class="c1"></span>    
    <span class="c1">// 散发数据到各个进程
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counts</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">displs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counts</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
        <span class="n">displs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
        <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">M</span> <span class="o">%</span> <span class="n">np</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span>
        <span class="n">displs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span>
            <span class="n">displs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">submat</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="n">MPI_Scatterv</span><span class="p">(</span>
        <span class="n">mat</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>      <span class="c1">// 发送缓冲区
</span><span class="c1"></span>        <span class="n">counts</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 向每个进程发多少个数据
</span><span class="c1"></span>        <span class="n">displs</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 每个数据块的起始位移
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="n">submat</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 接收缓冲区
</span><span class="c1"></span>        <span class="n">rows</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span>        <span class="c1">// 接收多少个数据，别忘了乘N
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>               <span class="c1">// 根进程
</span><span class="c1"></span>        <span class="n">MPI_COMM_WORLD</span>
    <span class="p">);</span>

    <span class="c1">// 从文件中读取向量数据
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">vec_file</span><span class="p">{</span><span class="s">&#34;vec.txt&#34;</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vec_file</span> <span class="o">&gt;&gt;</span> <span class="n">size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The number of columns &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">N</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; must&#34;</span>
                         <span class="s">&#34;be equal to the size of vector &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">vec_file</span> <span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 将向量广播到其它进程
</span><span class="c1"></span>    <span class="n">MPI_Bcast</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">N</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>

    <span class="c1">// 计算子矩阵与向量的积
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">subvec</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">subvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">submat</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 将结果收集到0号进程上，并输出。
</span><span class="c1"></span>    <span class="c1">// 如果将结果用于后续的矩阵乘向量，则应该使用MPI_Allgatherv。
</span><span class="c1"></span>    <span class="c1">// 如果将结果用于向量加减、数乘或者内积则不需要通信。
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">M</span> <span class="o">%</span> <span class="n">np</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">displs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">displs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">MPI_Gatherv</span><span class="p">(</span>
        <span class="n">subvec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 发送缓冲区
</span><span class="c1"></span>        <span class="n">rows</span><span class="p">,</span>            <span class="c1">// 本进程发送多少个数据
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="n">result</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 接收缓冲区
</span><span class="c1"></span>        <span class="n">counts</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 从各个进程接收多少个数据
</span><span class="c1"></span>        <span class="n">displs</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 从各个进程接收的数据放在何处
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>               <span class="c1">// 收集到0号进程上
</span><span class="c1"></span>        <span class="n">MPI_COMM_WORLD</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;calculate by parallel: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 串行计算对比
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;calculate by sequence: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">MPI_Finalize</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>其中mat.txt的内容为：</p>
<pre><code>12 12
  0    1    2    3    4    5    6    7    8    9   10   11
 12   13   14   15   16   17   18   19   20   21   22   23
 24   25   26   27   28   29   30   31   32   33   34   35
 36   37   38   39   40   41   42   43   44   45   46   47
 48   49   50   51   52   53   54   55   56   57   58   59
 60   61   62   63   64   65   66   67   68   69   70   71
 72   73   74   75   76   77   78   79   80   81   82   83
 84   85   86   87   88   89   90   91   92   93   94   95
 96   97   98   99  100  101  102  103  104  105  106  107
108  109  110  111  112  113  114  115  116  117  118  119
120  121  122  123  124  125  126  127  128  129  130  131
132  133  134  135  136  137  138  139  140  141  142  143
</code></pre><p>vec.txt的内容为：</p>
<pre><code>12
1 2 3 4 5 6 7 8 9 10 11 12
</code></pre><p>程序计算结果为：</p>
<pre><code>calculate by parallel: 
572, 1508, 2444, 3380, 4316, 5252, 6188, 7124, 8060, 8996, 9932, 10868
calculate by sequence:
572, 1508, 2444, 3380, 4316, 5252, 6188, 7124, 8060, 8996, 9932, 10868
</code></pre><p>并行和串行一致。</p>
<h4 id="例4使用聚合通信计算定积分"><a href="#例4使用聚合通信计算定积分" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:例4使用聚合通信计算定积分" class="headings">例4：使用聚合通信计算定积分</a></h4>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="nc">Interval</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">fc</span><span class="p">;</span>
    <span class="n">Interval</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">double</span> <span class="nf">Integrate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span>
                 <span class="kt">double</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-15</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 散发求值任务，使多次求函数值的过程并行进行。F的功能可以看作请求求值，结果放入v中，当
</span><span class="c1"></span>    <span class="c1">// v为nullptr时，功能为等待所有已提交的求值请求完成。
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">np</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">displs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">np</span><span class="p">];</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">x_save</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>    <span class="c1">// 保存需要求函数值的x
</span><span class="c1"></span>    <span class="kt">double</span> <span class="o">**</span><span class="n">f_save</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>   <span class="c1">// 保存对应的函数值返回地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="c1">// 已分配的单元个数，即有x_save有多少个可用单元
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">counts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">displs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x_save</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">f_save</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">](</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// 目前有多少个未计算函数值的x
</span><span class="c1"></span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 0号进程不发送数据
</span><span class="c1"></span>            <span class="n">displs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">displs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
            
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// 各进程计算任务个数
</span><span class="c1"></span>            <span class="c1">// 告知各进程有多少个点需要计算函数值
</span><span class="c1"></span>            <span class="n">MPI_Scatter</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
            <span class="c1">// 散发需要计算函数值的点
</span><span class="c1"></span>            <span class="n">MPI_Scatterv</span><span class="p">(</span><span class="n">x_save</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">displs</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span>
                      <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
            <span class="c1">// 收集计算好的函数值
</span><span class="c1"></span>            <span class="n">MPI_Gatherv</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span>
                      <span class="n">x_save</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">displs</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
            
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="o">*</span><span class="p">(</span><span class="n">f_save</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">=</span> <span class="n">x_save</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 需要增加内存
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="mi">128</span><span class="p">;</span>        <span class="c1">// 增加128个单元的内存
</span><span class="c1"></span>            <span class="n">x_save</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">x_save</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
            <span class="n">f_save</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">**</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">f_save</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">x_save</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">f_save</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="o">++</span><span class="n">n</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">eps</span> <span class="o">*=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>     <span class="c1">// 精度计算中的公因子预先算上
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Interval</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Interval</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">};</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 先计算各区间中点函数值
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">Interval</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
            <span class="n">F</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">);</span>
        
        <span class="c1">// 等待所有函数值计算完成
</span><span class="c1"></span>        <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>

        <span class="c1">// 计算各区间积分值，如果精度不够就继续细分
</span><span class="c1"></span>        <span class="n">Interval</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">h</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">-</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
            <span class="kt">double</span> <span class="n">xc</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
            <span class="kt">double</span> <span class="n">v0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">fa</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">);</span>
            <span class="kt">double</span> <span class="n">v1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v0</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">*</span> <span class="n">h</span><span class="p">);</span>

            <span class="c1">// 误差满足要求或者区间长度太小则计算此区间内的积分并将此区间移出C
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="o">*</span> <span class="n">eps</span> <span class="o">||</span> <span class="n">xc</span> <span class="o">==</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">||</span> <span class="n">xc</span> <span class="o">==</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">v1</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
                    <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
                    <span class="n">i</span><span class="o">-&gt;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">Interval</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 将i拆分成两个区间，i保留左半区间，i后面插入右半区间
</span><span class="c1"></span>            <span class="n">Interval</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Interval</span><span class="p">;</span>
            <span class="n">j</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="n">xc</span><span class="p">;</span>
            <span class="n">j</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>
            <span class="n">j</span><span class="o">-&gt;</span><span class="n">fa</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">;</span>
            <span class="n">j</span><span class="o">-&gt;</span><span class="n">fb</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">;</span>
            <span class="n">i</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">xc</span><span class="p">;</span>
            <span class="n">i</span><span class="o">-&gt;</span><span class="n">fb</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">;</span>
            <span class="n">j</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
                <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">j</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">// 跳过刚插入的j
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">counts</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">displs</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">x_save</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">f_save</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">4</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span> <span class="p">};</span>  <span class="c1">// 被积函数
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                                <span class="c1">// 积分区间
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-15</span><span class="p">;</span>                                 <span class="c1">// 积分精度
</span><span class="c1"></span>
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>

    <span class="c1">// 主从模式至少需要两个进程
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;This program needs at least two processes!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// n为各进程收到的计算请求个数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 0号进程作为主进程
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">Integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pi is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>

        <span class="c1">// 通知其它进程退出
</span><span class="c1"></span>        <span class="kt">int</span> <span class="o">*</span><span class="n">token</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">np</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">token</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">MPI_Scatter</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">token</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="o">*</span><span class="n">x_save</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 先接收有多少个主进程给本进程分配了多少个计算任务
</span><span class="c1"></span>            <span class="n">MPI_Scatter</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>

            <span class="c1">// n为-1时是退出信号，大于0时是F发来的计算任务个数
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">delete</span><span class="p">[]</span> <span class="n">x_save</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">// 空间不够，重新分配
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">delete</span><span class="p">[]</span> <span class="n">x_save</span><span class="p">;</span>
                <span class="n">x_save</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">// 接收需要计算函数值的点
</span><span class="c1"></span>            <span class="n">MPI_Scatterv</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">x_save</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
            
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">x_save</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_save</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            
            <span class="c1">// 将计算好的函数值收集到0号进程
</span><span class="c1"></span>            <span class="n">MPI_Gatherv</span><span class="p">(</span><span class="n">x_save</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">MPI_Finalize</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>这段代码使用new和delete管理内存，有兴趣的读者可以改为使用std::vector实现。</p>
<h3 id="进程同步"><a href="#进程同步" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:进程同步" class="headings">进程同步</a></h3>
<p>进程同步函数MPI_Barrier用于一个通信器中所有进程的同步。调用该函数时，进程将处于等待状态，直到通信器中所有进程都调用了该函数后才继续执行。其声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Barrier</span><span class="p">(</span>
    <span class="n">MPI_Comm</span> <span class="n">comm</span>
<span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>在前面的例子中，输出一个向量我们总是先把它收集到0号进程上再输出，过程十分繁琐，使用MPI_Barrier可以做到有序输出：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><h3 id="计算"><a href="#计算" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:计算" class="headings">计算</a></h3>
<p>计算操作有归约和扫描两种操作，归约是对分布于各个进程上的数据进行求和，而扫描是对分布于各个进程上的数据求前缀和。归约操作的函数有MPI_Reduce、MPI_Reduce_scatter和MPI_Allreduce，而扫描操作的函数为MPI_Scan。</p>
<h4 id="mpi_reduce"><a href="#mpi_reduce" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:mpi_reduce" class="headings">MPI_Reduce</a></h4>
<p>MPI_Reduce的声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Reduce</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址      
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>              <span class="c1">// 数据个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">datatype</span><span class="p">,</span>  <span class="c1">// 数据类型
</span><span class="c1"></span>    <span class="n">MPI_Op</span> <span class="n">op</span><span class="p">,</span>              <span class="c1">// 规约操作符
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">root</span><span class="p">,</span>               <span class="c1">// 根进程号
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>MPI_Reduce的示意图如下：</p>
<p><img src="assets/reduce.png" alt="reduce"></p>
<h4 id="mpi_allreduce"><a href="#mpi_allreduce" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:mpi_allreduce" class="headings">MPI_Allreduce</a></h4>
<p>MPI_Allreduce的声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Allreduce</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址      
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>              <span class="c1">// 数据个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">datatype</span><span class="p">,</span>  <span class="c1">// 数据类型
</span><span class="c1"></span>    <span class="n">MPI_Op</span> <span class="n">op</span><span class="p">,</span>              <span class="c1">// 规约操作符
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>全归约的操作与普通归约MPI_Reduce类似，但所有进程都会获得归约运算的结果，因此它和MPI_Reduce相比，少了一个root参数，其余参数的含义与MPI_Reduce完全相同。其示意图为</p>
<p><img src="assets/allreduce.png" alt="allreduce"></p>
<h4 id="mpi_reduce_scatter"><a href="#mpi_reduce_scatter" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:mpi_reduce_scatter" class="headings">MPI_Reduce_scatter</a></h4>
<p>MPI_Reduce_scatter的声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Reduce_scatter</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址      
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">recvcounts</span><span class="p">,</span>        <span class="c1">// 数据个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">datatype</span><span class="p">,</span>  <span class="c1">// 数据类型
</span><span class="c1"></span>    <span class="n">MPI_Op</span> <span class="n">op</span><span class="p">,</span>              <span class="c1">// 规约操作符
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>MPI_Reduce_scatter将归约的结果散发到各个进程上，散发时第i个进程接收recvcounts[i]个数据。参数中没有指明sendbuf的长度，因为参与归约的数组和归约的结果数组长度是相同的，因此最后散发的数据总量就是sendbuf的长度。</p>
<p>MPI_Reduce_scatter的示意图为：</p>
<p><img src="assets/reduce_scatter.png" alt="reduce_scatter"></p>
<h4 id="mpi_scan"><a href="#mpi_scan" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:mpi_scan" class="headings">MPI_Scan</a></h4>
<p>扫描操作就是求前缀和，将前i个进程的归约结果放在第i个进程的接收缓冲区内。其声明为：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">MPI_Scan</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sendbuf</span><span class="p">,</span>          <span class="c1">// 发送缓冲区的起始地址      
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">recvbuf</span><span class="p">,</span>          <span class="c1">// 接收缓冲区的起始地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>              <span class="c1">// 输入缓冲区中元素的个数
</span><span class="c1"></span>    <span class="n">MPI_Datatype</span> <span class="n">datatype</span><span class="p">,</span>  <span class="c1">// 数据类型
</span><span class="c1"></span>    <span class="n">MPI_Op</span> <span class="n">op</span><span class="p">,</span>              <span class="c1">// 规约操作符
</span><span class="c1"></span>    <span class="n">MPI_Comm</span> <span class="n">comm</span>           <span class="c1">// 通信器
</span><span class="c1"></span><span class="p">);</span>
</code></pre></td></tr></table></div>
</div>
</div><p>其示意图为：</p>
<p><img src="assets/scan.png" alt="scan"></p>
<h4 id="二元运算"><a href="#二元运算" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:二元运算" class="headings">二元运算</a></h4>
<div class="table-container"><table>
<thead>
<tr>
<th>MPI_Op</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MPI_MAX</td>
<td>两个操作数中较大的一个</td>
</tr>
<tr>
<td>MPI_MIN</td>
<td>两个操作数中较小的一个</td>
</tr>
<tr>
<td>MPI_SUM</td>
<td>两个操作数之和</td>
</tr>
<tr>
<td>MPI_PROD</td>
<td>两个操作数之积</td>
</tr>
<tr>
<td>MPI_LAND</td>
<td>两个操作数的逻辑与(logical and)</td>
</tr>
<tr>
<td>MPI_BAND</td>
<td>两个操作数的按位与(bitwise and)</td>
</tr>
<tr>
<td>MPI_LOR</td>
<td>两个操作数的逻辑或(logical or)</td>
</tr>
<tr>
<td>MPI_BOR</td>
<td>两个操作数的按位或(bitwise or)</td>
</tr>
<tr>
<td>MPI_LXOR</td>
<td>两个操作数的逻辑异或(logical xor)</td>
</tr>
<tr>
<td>MPI_BXOR</td>
<td>两个操作数的按位异或(bitwise xor)</td>
</tr>
<tr>
<td>MPI_MAXLOC</td>
<td>两对操作数的最大值和最大值的位置(u,i)op(v,j)=(max(u,v),k)</td>
</tr>
<tr>
<td>MPI_MINLOC</td>
<td>两对操作数的最小值和最小值的位置(u,i)op(v,j)=(min(u,v),k)</td>
</tr>
</tbody>
</table></div>
<p>其中最后两个运算的使用方法稍微复杂一些，示例如下：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="n">LEN</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">val</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>    <span class="c1">// 用于保存数据，最大长度为LEN
</span><span class="c1"></span><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>         <span class="c1">// 每个进程有count个数据
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">minrank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 最小值在哪个进程上
</span><span class="c1"></span><span class="kt">int</span> <span class="n">minindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 最小值在哪个下标上
</span><span class="c1"></span><span class="kt">float</span> <span class="n">minval</span><span class="p">;</span>      <span class="c1">// 最小值
</span><span class="c1"></span>
<span class="k">struct</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">;</span>

<span class="c1">// 每个进程进行局部归约
</span><span class="c1"></span><span class="n">in</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">in</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">in</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">in</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">in</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">id</span> <span class="o">*</span> <span class="n">LEN</span> <span class="o">+</span> <span class="n">in</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
    
<span class="n">MPI_Reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_FLOAT_INT</span><span class="p">,</span> <span class="n">MPI_MINLOC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>

<span class="n">minval</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="n">minrank</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="n">index</span> <span class="o">/</span> <span class="n">LEN</span><span class="p">;</span>    <span class="c1">// 最小值在哪个进程上
</span><span class="c1"></span><span class="n">minindex</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="n">index</span> <span class="o">%</span> <span class="n">LEN</span><span class="p">;</span>   <span class="c1">// 最小值在val的哪个位置
</span></code></pre></td></tr></table></div>
</div>
</div><p>其中自定义的结构体的类型在MPI中为：</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">MPI_FLOAT_INT</td>
<td align="left">浮点型和整形</td>
</tr>
<tr>
<td align="left">MPI_DOUBLE_INT</td>
<td align="left">双精度和整形</td>
</tr>
<tr>
<td align="left">MPI_LONG_INT</td>
<td align="left">长整形和整形</td>
</tr>
<tr>
<td align="left">MPI_2INT</td>
<td align="left">整型值对</td>
</tr>
<tr>
<td align="left">MPI_SHORT_INT</td>
<td align="left">短整形和整形</td>
</tr>
<tr>
<td align="left">MPI_LONG_DOUBLE_INT</td>
<td align="left">长双精度浮点型和整型</td>
</tr>
</tbody>
</table></div>
<h4 id="例5列主序下矩阵与向量乘法"><a href="#例5列主序下矩阵与向量乘法" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:例5列主序下矩阵与向量乘法" class="headings">例5：列主序下矩阵与向量乘法</a></h4>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="p">);</span>
    
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 打开一个数据文件，从里面读出矩阵的数据
</span><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">mat_file</span><span class="p">{</span><span class="s">&#34;mat.txt&#34;</span><span class="p">};</span>
        
        <span class="c1">// 列数和行数
</span><span class="c1"></span>        <span class="n">mat_file</span> <span class="o">&gt;&gt;</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

        <span class="c1">// 矩阵数据
</span><span class="c1"></span>        <span class="n">mat</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">mat_file</span> <span class="o">&gt;&gt;</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="n">MPI_Bcast</span><span class="p">(</span><span class="n">dim</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>   <span class="c1">// 行数
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// 列数
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 本进程多少列
</span><span class="c1"></span>    
    <span class="c1">// 散发数据到各个进程
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counts</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">displs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counts</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
        <span class="n">displs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
        <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
        <span class="n">displs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span>
            <span class="n">displs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">submat</span><span class="p">(</span><span class="n">cols</span> <span class="o">*</span> <span class="n">M</span><span class="p">);</span>
    <span class="n">MPI_Scatterv</span><span class="p">(</span>
        <span class="n">mat</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>      <span class="c1">// 发送缓冲区
</span><span class="c1"></span>        <span class="n">counts</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 向每个进程发多少个数据
</span><span class="c1"></span>        <span class="n">displs</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 每个数据块的起始位移
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="n">submat</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 接收缓冲区
</span><span class="c1"></span>        <span class="n">cols</span> <span class="o">*</span> <span class="n">M</span><span class="p">,</span>        <span class="c1">// 接收多少个数据，别忘了乘M
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>               <span class="c1">// 根进程
</span><span class="c1"></span>        <span class="n">MPI_COMM_WORLD</span>
    <span class="p">);</span>

    <span class="c1">// 从文件中读取向量数据
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">vec_file</span><span class="p">{</span><span class="s">&#34;vec.txt&#34;</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vec_file</span> <span class="o">&gt;&gt;</span> <span class="n">size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The number of columns &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">N</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; must&#34;</span>
                         <span class="s">&#34;be equal to the size of vector &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">vec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">vec_file</span> <span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 将向量散发到其它进程
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">subvec</span><span class="p">(</span><span class="n">cols</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">displs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">np</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">%</span> <span class="n">np</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">displs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">MPI_Scatterv</span><span class="p">(</span>
        <span class="n">vec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>      <span class="c1">// 发送缓冲区
</span><span class="c1"></span>        <span class="n">counts</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 向每个进程发多少个数据
</span><span class="c1"></span>        <span class="n">displs</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 每个数据块的起始位移
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="n">subvec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>   <span class="c1">// 接收缓冲区
</span><span class="c1"></span>        <span class="n">cols</span><span class="p">,</span>            <span class="c1">// 接收多少个数据
</span><span class="c1"></span>        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>               <span class="c1">// 根进程
</span><span class="c1"></span>        <span class="n">MPI_COMM_WORLD</span>
    <span class="p">);</span>

    <span class="c1">// 计算子矩阵与向量的积
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">partial_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// for (int i = 0; i &lt; M; ++i) {
</span><span class="c1"></span>    <span class="c1">//     for (int j = 0; j &lt; cols; ++j)
</span><span class="c1"></span>    <span class="c1">//         partial_vec[i] += submat[j * M + i] * vec[j];
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">partial_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">submat</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">subvec</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 将结果归约到0号进程上，并输出
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>

    <span class="n">MPI_Reduce</span><span class="p">(</span>
        <span class="n">partial_vec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
        <span class="n">result</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
        <span class="n">M</span><span class="p">,</span>
        <span class="n">MPI_DOUBLE</span><span class="p">,</span>
        <span class="n">MPI_SUM</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="n">MPI_COMM_WORLD</span>
    <span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;calculate by parallel: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 串行计算对比
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;calculate by sequence: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">M</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">MPI_Finalize</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>运行结果：</p>
<pre><code>calculate by parallel:
6864, 6942, 7020, 7098, 7176, 7254, 7332, 7410, 7488, 7566, 7644, 7722
calculate by sequence:
6864, 6942, 7020, 7098, 7176, 7254, 7332, 7410, 7488, 7566, 7644, 7722
</code></pre><p>文件mat.txt和vec.txt的内容和之前相同，但这次将mat.txt看作列主序存储，即首行两个数分别表示列数和行数，接下来每一行数据都表示矩阵一列。从计算结果来看，并行计算和串行计算结果相同。</p>
<h3 id="文档"><a href="#文档" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href="#contents:文档" class="headings">文档</a></h3>
<p>[1] <a href="https://www.open-mpi.org/doc/current/" target="_blank" rel="noopener">https://www.open-mpi.org/doc/current/</a>.</p>
<p>[2] <a href="https://www.mpich.org/static/docs/latest/" target="_blank" rel="noopener">https://www.mpich.org/static/docs/latest/</a>.</p>
<p>[3] <a href="https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf" target="_blank" rel="noopener">https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf</a>.</p>

            </div>

        </article>

        

        
    
    
        <ul class="post-copyright">
            <li class="copyright-item author"><span class="copyright-item-text">作者</span>：<a href="https://w-jin.gitee.com/" target="_blank" rel="noopener">wjin</a></li>
            
                
                
                
                
                <li class="copyright-item link"><span class="copyright-item-text">链接</span>：<a href="/posts/mpi%E6%95%99%E7%A8%8B3/" target="_blank" rel="noopener">https://w-jin.gitee.com/posts/mpi教程3/</a></li>
            
            <li class="copyright-item license"><span class="copyright-item-text">许可</span>：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></li>
            
        </ul>
    



        


        


        


        
    
    
        <div class="related-posts">
            <h2 class="related-title">相关文章：<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon related-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"/></svg></h2>
            <ul class="related-list">
                
                    <li class="related-item">
                        <a href="/posts/mpi%E6%95%99%E7%A8%8B4/" class="related-link">MPI教程4</a>
                    </li>
                
                    <li class="related-item">
                        <a href="/posts/mpi%E6%95%99%E7%A8%8B2/" class="related-link">MPI教程2</a>
                    </li>
                
                    <li class="related-item">
                        <a href="/posts/mpi%E6%95%99%E7%A8%8B1/" class="related-link">MPI教程1</a>
                    </li>
                
                    <li class="related-item">
                        <a href="/posts/c&#43;&#43;%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8Ctbb%E6%95%99%E7%A8%8B/" class="related-link">c++函数式编程与TBB教程</a>
                    </li>
                
                    <li class="related-item">
                        <a href="/posts/openmp%E6%95%99%E7%A8%8B/" class="related-link">OpenMP教程</a>
                    </li>
                
            </ul>
        </div>
    



        
    
        <div class="post-tags">
            
                
                
                
                
                    
                    <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>并行计算</a>
                
            
                
                
                
                
                    
                    <a href="/tags/mpi/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>MPI</a>
                
            
        </div>
    



        


        


        
    
        
        
    
    
    
    
        <ul class="post-nav">
            
                <li class="post-nav-prev">
                    <a href="/posts/mpi%E6%95%99%E7%A8%8B4/" rel="prev">&lt; MPI教程4</a>
                </li>
            
            
                <li class="post-nav-next">
                    <a href="/posts/mpi%E6%95%99%E7%A8%8B2/" rel="next">MPI教程2 &gt;</a>
                </li>
            
        </ul>
    



        


    </div>
</main>


            
    <div id="back-to-top" class="back-to-top">
        <a href="#"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a>
    </div>


            
    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="site-info">©&nbsp;1999–2020&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;wjin</div><div class="powered-by">Powered by <a href="https://github.com/gohugoio/hugo" target="_blank" rel="noopener">Hugo</a> | Theme is <a href="https://github.com/reuixiy/hugo-theme-meme" target="_blank" rel="noopener">MemE</a></div><div class="site-copyright"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div>

            


            
        </div>
    </footer>


        </div>
        

        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous" />
<script>
    if (typeof renderMathInElement === 'undefined') {
        var getScript = (options) => {
            var script = document.createElement('script');
            script.defer = true;
            script.crossOrigin = 'anonymous';
            Object.keys(options).forEach((key) => {
                script[key] = options[key];
            });
            document.body.appendChild(script);
        };
        getScript({
            src: 'https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js',
            integrity: 'sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1',
            onload: () => {
                getScript({
                    src: 'https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/mhchem.min.js',
                    integrity: 'sha384-oa0lfxCGjaU1LdYckhq8LZcP+JTf8cyJXe69O6VE6UrShzWveT6KiCElJrck/stm',
                    onload: () => {
                        getScript({
                            src: 'https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js',
                            integrity: 'sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI',
                            onload: () => {
                                renderKaTex();
                            }
                        });
                    }
                });
            }
        });
    } else {
        renderKaTex();
    }
    function renderKaTex() {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    }
</script>









    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js"></script>

<script>
    mediumZoom(document.querySelectorAll('div.post-body img'), {
        background: 'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'
    })
</script>




    <script src="https://cdn.jsdelivr.net/npm/instant.page@3.0.0/instantpage.min.js" type="module" defer></script>







    </body>
</html>
